.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "LiteratureBasedDiscovery 3pm"
.TH LiteratureBasedDiscovery 3pm "2017-11-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
ALBD \- a perl implementation of Literature Based Discovery
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&    use ALBD;
\&    %options = ();
\&    $options{\*(AqlbdConfig\*(Aq} = \*(AqconfigFile\*(Aq
\&    my $lbd = LiteratureBasedDiscovery\->new(\e%options);
\&    $lbd\->performLBD();
.Ve
.SH "ABSTRACT"
.IX Header "ABSTRACT"
.Vb 9
\&      This package consists of Perl modules along with supporting Perl
\&      programs that perform Literature Based Discovery (LBD). The core 
\&      data from which LBD is performed are co\-occurrences matrices 
\&      generated from UMLS::Association. ALBD is based on the ABC
\&      co\-occurrence model. Many options can be specified, and many
\&      ranking methods are available. The novel ranking methods that use
\&      association measure are available as well as frequency based
\&      ranking methods. See samples/lbd for more info. Can perform open and
\&      closed LBD as well as time slicing evaluation.
.Ve
.SH "INSTALL"
.IX Header "INSTALL"
To install the module, run the following magic commands:
.PP
.Vb 4
\&  perl Makefile.PL
\&  make
\&  make test
\&  make install
.Ve
.PP
This will install the module in the standard location. You will, most
probably, require root privileges to install in standard system
directories. To install in a non-standard directory, specify a prefix
during the 'perl Makefile.PL' stage as:
.PP
.Vb 1
\&  perl Makefile.PL PREFIX=/home/sid
.Ve
.PP
It is possible to modify other parameters during installation. The
details of these can be found in the ExtUtils::MakeMaker
documentation. However, it is highly recommended not messing around
with other parameters, unless you know what you're doing.
.SH "CONFIGURATION FILE"
.IX Header "CONFIGURATION FILE"
There are many parameters that can be specified, both for open and
close discovery as well as time slicing evaluation. Please see the 
samples folder for info and sample configuration files.
.PP
#Get inputs
    my \f(CW$startCuisRef\fR = \f(CW$self\fR\->\fI_getStartCuis()\fR;
    my \f(CW$linkingAcceptTypesRef\fR = \f(CW$self\fR\->_getAcceptTypes('linking');
    my \f(CW$targetAcceptTypesRef\fR = \f(CW$self\fR\->_getAcceptTypes('target');
    print \*(L"startCuis = \*(R".(join(',', @{$startCuisRef})).\*(L"\en\*(R";
    print \*(L"linkingAcceptTypes = \*(R".(join(',', keys %{$linkingAcceptTypesRef})).\*(L"\en\*(R";
    print \*(L"targetAcceptTypes = \*(R".(join(',', keys %{$targetAcceptTypesRef})).\*(L"\en\*(R";
.PP
#Score Implicit Connections
    \f(CW$start\fR = \fItime()\fR;	
    my \f(CW$scoresRef\fR;
    \f(CW$scoresRef\fR = Rank::scoreImplicit_fromImplicitMatrix($startCuisRef,  \f(CW$lbdOptions\fR{'implicitInputFile'}, \f(CW$lbdOptions\fR{rankingMeasue}, \f(CW$umls_association\fR);
    print \*(L"Scored in: \*(R".(\fItime()\fR\-$start).\*(L"\en\*(R";
.PP
#Rank Implicit Connections
    \f(CW$start\fR = \fItime()\fR;
    my \f(CW$ranksRef\fR = Rank::rankDescending($scoresRef);
    print \*(L"Ranked in: \*(R".(\fItime()\fR\-$start).\*(L"\en\*(R";
.PP
#Output The Results
    open \s-1OUT, \*(L"\s0>$lbdOptions{implicitOutputFile}\*(R" 
	or die \*(L"unable to open implicit ouput file: \*(R"
	.\*(L"$lbdOptions{implicitOutputFile}\en\*(R";
    my \f(CW$outputString\fR = \f(CW$self\fR\->_rankedTermsToString($scoresRef, \f(CW$ranksRef\fR);
    my \f(CW$paramsString\fR = \f(CW$self\fR\->\fI_parametersToString()\fR;
    print \s-1OUT\s0 \f(CW$paramsString\fR;
    print \s-1OUT\s0 \f(CW$outputString\fR;
    close \s-1OUT\s0;
.PP
#Done
    print \*(L"\s-1DONE\s0!\en\en\*(R";
}
.PP
.Vb 1
\&    print "Starting CUIs = ".(join(\*(Aq,\*(Aq, @{$startingCuisRef}))."\en";
.Ve
.PP
#Get the Explicit Matrix
    my ($explicitMatrixRef, \f(CW$cuiToIndexRef\fR, \f(CW$indexToCuiRef\fR, \f(CW$matrixSize\fR) = 
	Discovery::tableToSparseMatrix('N_11', \f(CW$cuiFinder\fR);
    print \*(L"Explicit Matrix:\en\*(R";
    _printMatrix($explicitMatrixRef, \f(CW$matrixSize\fR, \f(CW$indexToCuiRef\fR);
    print \*(L"\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\en\*(R";
.PP
#Get the Starting Matrix
    my \f(CW$startingMatrixRef\fR = 
	Discovery::getRows($startingCuisRef, \f(CW$explicitMatrixRef\fR);
    print \*(L"Starting Matrix:\en\*(R";
    _printMatrix($startingMatrixRef, \f(CW$matrixSize\fR, \f(CW$indexToCuiRef\fR);
    print \*(L"\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\en\*(R";
.PP
#Get Implicit Connections
    my \f(CW$implicitMatrixRef\fR 
	= Discovery::findImplicit($explicitMatrixRef, \f(CW$startingMatrixRef\fR, 
				  \f(CW$indexToCuiRef\fR, \f(CW$matrixSize\fR);
    print \*(L"Implicit Matrix:\en\*(R";
    _printMatrix($implicitMatrixRef, \f(CW$matrixSize\fR, \f(CW$indexToCuiRef\fR);
    print \*(L"\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\en\*(R";
.PP
#Remove Known Connections
    \f(CW$implicitMatrixRef\fR = Discovery::removeExplicit($explicitMatrixRef, 
						   \f(CW$implicitMatrixRef\fR);
    print \*(L"Implicit Matrix with Explicit Removed\en\*(R";
    _printMatrix($implicitMatrixRef, \f(CW$matrixSize\fR, \f(CW$indexToCuiRef\fR);
    print \*(L"\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\en\*(R";
    print \*(L"\en\en\*(R";
.PP
#Test N11, N1P, etc...
    #NOTE...always do n11 first, if n11 = \-1, no need to compute the others...there is no co-occurrence between them
    my \f(CW$n11\fR = Rank::getN11('C0','C2',$explicitMatrixRef);
    my \f(CW$npp\fR = Rank::getNPP($explicitMatrixRef);
    my \f(CW$n1p\fR = Rank::getN1P('C0', \f(CW$explicitMatrixRef\fR);
    my \f(CW$np1\fR = Rank::getNP1('C2', \f(CW$explicitMatrixRef\fR); 
    print \*(L"Contingency Table Values from Explicit Matrix\en\*(R";
    print \*(L"n11 = \f(CW$n11\fR\en\*(R";
    print \*(L"npp = \f(CW$npp\fR\en\*(R";
    print \*(L"n1p = \f(CW$n1p\fR\en\*(R";
    print \*(L"np1 = \f(CW$np1\fR\en\*(R";
.PP
#Test other rank methods
    my \f(CW$scoresRef\fR = Rank::scoreImplicit_fromAllPairs($startingMatrixRef, \f(CW$explicitMatrixRef\fR, \f(CW$implicitMatrixRef\fR, \f(CW$lbdOptions\fR{rankingMethod}, \f(CW$umls_association\fR);
    my \f(CW$ranksRef\fR = Rank::rankDescending($scoresRef);
    print \*(L"Scores: \en\*(R";
    foreach my \f(CW$cui\fR (keys %{$scoresRef}) {
	print \*(L"   scores{$cui} = ${$scoresRef}{$cui}\en\*(R";
    }
    print \*(L"Ranks = \*(R".join(',', @{$ranksRef}).\*(L"\en\*(R";
}
.PP
sub _printMatrix {
    my \f(CW$matrixRef\fR = shift;
    my \f(CW$matrixSize\fR = shift;
    my \f(CW$indexToCuiRef\fR = shift;
.PP
.Vb 6
\&    for (my $i = 0; $i < $matrixSize; $i++) {
\&        my $index1 = ${$indexToCuiRef}{$i};
\&        for (my $j = 0; $j < $matrixSize; $j++) {
\&            my $printed = 0;
\&            my $index2 = ${$indexToCuiRef}{$j};
\&            my $hash1Ref =  ${$matrixRef}{$index1};
\&
\&            if (defined $hash1Ref) {
\&                my $val = ${$hash1Ref}{$index2};
\&                if (defined $val) {
\&                    print $val."\et";
\&                    $printed = 1;
\&                }
\&            }
\&            if (!$printed) {
\&                print "0\et";
\&            }
\&        }
\&        print "\en";
\&    }
\&}
.Ve
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 421:" 4
.IX Item "Around line 421:"
Unknown directive: =comment
.IP "Around line 1055:" 4
.IX Item "Around line 1055:"
Unknown directive: =comment
